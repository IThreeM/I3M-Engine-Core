//! Tile set is a special storage for tile descriptions. It is a sort of database, that contains
//! descriptions (definitions) for tiles. See [`TileSet`] docs for more info and usage examples.

use crate::{
    asset::{
        io::ResourceIo,
        loader::{BoxedLoaderFuture, LoaderPayload, ResourceLoader},
        manager::ResourceManager,
        state::LoadError,
        Resource, ResourceData,
    },
    core::{
        color::Color,
        io::FileLoadError,
        math::Rect,
        pool::{Handle, Pool},
        reflect::prelude::*,
        type_traits::prelude::*,
        visitor::prelude::*,
    },
    material::MaterialResource,
};
use std::{
    any::Any,
    error::Error,
    fmt::{Display, Formatter},
    path::{Path, PathBuf},
    sync::Arc,
};
use strum_macros::{AsRefStr, EnumString, VariantNames};

/// An error that may occur during tile set resource loading.
#[derive(Debug)]
pub enum TileSetResourceError {
    /// An i/o error has occurred.
    Io(FileLoadError),

    /// An error that may occur due to version incompatibilities.
    Visit(VisitError),
}

impl Display for TileSetResourceError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Io(v) => {
                write!(f, "A file load error has occurred {v:?}")
            }
            Self::Visit(v) => {
                write!(
                    f,
                    "An error that may occur due to version incompatibilities. {v:?}"
                )
            }
        }
    }
}

impl From<FileLoadError> for TileSetResourceError {
    fn from(e: FileLoadError) -> Self {
        Self::Io(e)
    }
}

impl From<VisitError> for TileSetResourceError {
    fn from(e: VisitError) -> Self {
        Self::Visit(e)
    }
}

/// Supported collider types for tiles.
#[derive(
    Copy,
    Clone,
    Hash,
    PartialEq,
    Eq,
    Debug,
    Default,
    Visit,
    Reflect,
    AsRefStr,
    EnumString,
    VariantNames,
    TypeUuidProvider,
)]
#[type_uuid(id = "04a44fec-394f-4497-97d5-fe9e6f915831")]
pub enum TileCollider {
    /// No collider.
    None,
    /// Rectangle collider.
    #[default]
    Rectangle,
    /// Mesh collider, the mesh is autogenerated.
    Mesh,
}

/// Definition of a tile.
#[derive(Clone, Default, Debug, Reflect, Visit)]
pub struct TileDefinition {
    /// Material of the tile.
    pub material: MaterialResource,
    /// A rectangle, that defines texture coordinates range for the tile.
    pub uv_rect: Rect<f32>,
    /// Collider of the tile.
    pub collider: TileCollider,
    /// Color of the tile.
    pub color: Color,
}

/// An alias for `Handle<TileDefinition>`.
pub type TileDefinitionHandle = Handle<TileDefinition>;

/// Tile set is a special storage for tile descriptions. It is a sort of database, that contains
/// descriptions (definitions) for tiles. Such approach allows you to change appearance of all tiles
/// of particular kind at once.
#[derive(Clone, Default, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "7b7e057b-a41e-4150-ab3b-0ae99f4024f0")]
pub struct TileSet {
    /// Tiles of the tile set.
    pub tiles: Pool<TileDefinition>,
}

impl TileSet {
    /// Adds a tile definition to the tile set and returns its handle.
    pub fn add_tile(&mut self, tile: TileDefinition) -> TileDefinitionHandle {
        self.tiles.spawn(tile)
    }

    /// Load a tile set resource from the specific file path.
    pub async fn from_file(
        path: &Path,
        resource_manager: ResourceManager,
        io: &dyn ResourceIo,
    ) -> Result<Self, TileSetResourceError> {
        let bytes = io.load_file(path).await?;
        let mut visitor = Visitor::load_from_memory(&bytes)?;
        visitor.blackboard.register(Arc::new(resource_manager));
        let mut tile_set = TileSet::default();
        tile_set.visit("TileSet", &mut visitor)?;
        Ok(tile_set)
    }
}

impl ResourceData for TileSet {
    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }

    fn type_uuid(&self) -> Uuid {
        <Self as TypeUuidProvider>::type_uuid()
    }

    fn save(&mut self, path: &Path) -> Result<(), Box<dyn Error>> {
        let mut visitor = Visitor::new();
        self.visit("TileSet", &mut visitor)?;
        visitor.save_binary(path)?;
        Ok(())
    }

    fn can_be_saved(&self) -> bool {
        true
    }
}

/// An alias for `Resource<TileSet>`.
pub type TileSetResource = Resource<TileSet>;

/// Standard tile set resource loader.
pub struct TileSetLoader {
    /// Resource manager of the engine.
    pub resource_manager: ResourceManager,
}

impl ResourceLoader for TileSetLoader {
    fn extensions(&self) -> &[&str] {
        &["tileset"]
    }

    fn data_type_uuid(&self) -> Uuid {
        <TileSet as TypeUuidProvider>::type_uuid()
    }

    fn load(&self, path: PathBuf, io: Arc<dyn ResourceIo>) -> BoxedLoaderFuture {
        let resource_manager = self.resource_manager.clone();
        Box::pin(async move {
            let tile_set = TileSet::from_file(&path, resource_manager, io.as_ref())
                .await
                .map_err(LoadError::new)?;
            Ok(LoaderPayload::new(tile_set))
        })
    }
}
